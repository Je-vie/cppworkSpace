主要介绍头文件和实现文件不同名的情况下，编译器是如何找到实现的

这里定义了head.h 和body.cpp 
main.cpp 中include"head.h" 

其实编译器在编译main.cpp的时候是通过指定要编译的cpp文件（头文件不用编译）
如： g++ main.cpp body.cpp 

上面这一条编译指令包括了预处理、编译、汇编、链接 
1、 预处理的时候就会将head.h中的所有内容都copy到main.cpp的开头处（即将函数声明都copy进来，也可以有函数定义，如果头文件中定义了函数体）

2、在这个例子中（声明和实现在两个文件中）汇编之前，main.cpp都只是得到了需要引用的函数print的声明，并不知道实现体，

3、 只有在链接的时候，编译器会找指定的.o文件，看有没有print函数的定义，然后进行链接（即地址链接），因为指定的是body.cpp 所以能找到。

总结： 
1、头文件和实现文件并不想java一样需要同名，所以，所有cpp文件最后都会生成对应的同名.o文件，这些.o文件就是一个个编译单元，所有编译单元构成一个工程。函数入口是main函数。
2、如果是面向对象编程，每个编译单元最好设计成一个个类，每个类又对应有同名的头文件。
3、因为c++是一个大联邦，并不像java 需要所有代码都写在类里面，他同时支持面向过程编程，所以必然有类外的东西，即全局函数、全局变量。
4、全局函数和全局变量的作用域是整个工程都看得到的，全局变量在静态段，全局函数在代码段。所以全局函数和全局变量不能重名。
5、当工程比较大的时候，使用全局函数和变量的时候，难免有可能会重复（比如库函数中必然有重名），所以就有了命名空间，一般一个模块用一个命名空间。

